- **풀기 전 생각**
    1. LIS 문제다.
    2. A→B로 가는 가장 길이가 긴 부분 증가/감소 수열만 없애보자..?
    - Q: 대체 길이 몇 수준까지 지워야 한다고 볼 것인가..?

→ X 이런 식으로 푸는 건 완전 틀리게 됨. 구현이 매우 복잡하며 로직을 생각하는 것도 불가능.

JW: A에서 차례대로 도착하는 B의 값으로 수열을 만들어보자.
그리고 그 수열을 가지고 LIS를 생각해보자.

A: N- max(LIS)

8
1 8
3 9
2 2
4 1
6 4
10 10
9 7
7 6

!!!!
틀림

이유: A를 정렬 후에 B에 대한 LIS 계산 하고 N-LIS 해야함
앞서 말한 케이스는 오로지 A가 
1 3
2 5 
3 8
4 7

처럼 오름차순 정렬 기준이라고 생각하고 진행된다.
그러니 pair<int, int> 를 통한 정렬이 필수다.

















#ex
1 5 3 6

dp[0] =1

i=1 j=0
dp[1] = max(dp[1], dp[0]+1) = 2

i=2 j=0
dp[2] = max(dp[2], dp[0]+1) = 2
i=2 j=1 pass

i=3 j=0
dp[3] = max(dp[3], dp[0]+1) =2
i=3 j=1
dp[3] = max(dp[3], dp[1]+1) =3
i=3 j=2
dp[3] = max(dp[3], dp[2]+1) =3
