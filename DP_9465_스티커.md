10 30 10 50 100 20 40
20 40 30 50 60 20 80


dp배열의 관리

d[i][0] → i번째 열에서 위쪽 스티커를 땜으로써 얻을 수 있는 최대 점수
-> max(d[i-1][1], d[i-1][2]) + arr[0][i]

d[i][1] → i번째 열에서 아래쪽 스티커를 땜으로써 얻을 수 있는 최대 점수
-> max(d[i-1][0], d[i-1][2]) + arr[1][i]

d[i][2] → i번째 열에서 가만히 냅둠으로써 얻을 수 있는 최대 점수
-> max(d[i-1][0], d[i-1][1], d[i-1][2])

이러한 논리가 가능한 이유: 2행으로 고정되어 있기 때문이다.


50 10 100 20 40
30 50 70  10 60


d[1][0] = max(30+10, 0) + 10 = 40
d[1][1] = max(50+50, 0) + 50 = 100
d[1][2] = max(50, 30, 0) = 50

d[2][0] = max(100, 50) + 100 = 200
d[2][1] = max(40, 50) + 70 = 120
d[2][2] = max(40, 100, 50) = 100

d[3][0] = max(120, 100) + 20 = 140
d[3][1] = max(200, 100) + 10 = 210
d[3][2] = max(200, 120, 100) = 200

d[4][0] = max(210, 200) + 40 = 250
d[4][1] = max(140, 200) + 60 = 260
d[4][2] = max(140, 210, 200) = 210